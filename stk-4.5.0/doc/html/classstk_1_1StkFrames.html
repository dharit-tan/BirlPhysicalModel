<HTML>
<HEAD>
<TITLE>The Synthesis ToolKit in C++ (STK)</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<img src="princeton.gif"> &nbsp; <img src="ccrma.gif"> &nbsp; <img src="mcgill.gif"><P>
<a class="qindex" href="index.html">Home</a> &nbsp; <a class="qindex" href="information.html">Information</a> &nbsp; <a class="qindex" href="classes.html">Classes</a> &nbsp; <a class="qindex" href="download.html">Download</a> &nbsp; <a class="qindex" href="usage.html">Usage</a> &nbsp; <a class="qindex" href="maillist.html">Mail List</a> &nbsp; <a class="qindex" href="system.html">Requirements</a> &nbsp; <a class="qindex" href="links.html">Links</a> &nbsp; <a class="qindex" href="faq.html">FAQ</a> &nbsp; <a class="qindex" href="tutorial.html">Tutorial</a></CENTER>
<HR>
<!-- Generated by Doxygen 1.8.3.1 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestk.html">stk</a></li><li class="navelem"><a class="el" href="classstk_1_1StkFrames.html">StkFrames</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstk_1_1StkFrames-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">stk::StkFrames Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An STK class to handle vectorized audio data.  
 <a href="classstk_1_1StkFrames.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Stk_8h_source.html">Stk.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa9ad14889de633ba4269f1330be8bedf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9ad14889de633ba4269f1330be8bedf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#aa9ad14889de633ba4269f1330be8bedf">StkFrames</a> (unsigned int nFrames=0, unsigned int nChannels=0)</td></tr>
<tr class="memdesc:aa9ad14889de633ba4269f1330be8bedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor initializes the frame data structure to size zero. <br/></td></tr>
<tr class="separator:aa9ad14889de633ba4269f1330be8bedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48aabe6cf029c06d2aa8a5fedf3621e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac48aabe6cf029c06d2aa8a5fedf3621e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#ac48aabe6cf029c06d2aa8a5fedf3621e">StkFrames</a> (const StkFloat &amp;value, unsigned int nFrames, unsigned int nChannels)</td></tr>
<tr class="memdesc:ac48aabe6cf029c06d2aa8a5fedf3621e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded constructor that initializes the frame data to the specified size with <code>value</code>. <br/></td></tr>
<tr class="separator:ac48aabe6cf029c06d2aa8a5fedf3621e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa9a0a175de2b18e75d9b68a6387895"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fa9a0a175de2b18e75d9b68a6387895"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#a3fa9a0a175de2b18e75d9b68a6387895">~StkFrames</a> ()</td></tr>
<tr class="memdesc:a3fa9a0a175de2b18e75d9b68a6387895"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor. <br/></td></tr>
<tr class="separator:a3fa9a0a175de2b18e75d9b68a6387895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed9cc0a4309f786cfe36da9e901fde9"><td class="memItemLeft" align="right" valign="top">StkFloat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#a8ed9cc0a4309f786cfe36da9e901fde9">operator[]</a> (size_t n)</td></tr>
<tr class="memdesc:a8ed9cc0a4309f786cfe36da9e901fde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator that returns a reference to element <code>n</code> of self.  <a href="#a8ed9cc0a4309f786cfe36da9e901fde9">More...</a><br/></td></tr>
<tr class="separator:a8ed9cc0a4309f786cfe36da9e901fde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1c8a2b32725ca72e0f3256f9cd8cb6"><td class="memItemLeft" align="right" valign="top">StkFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#a2d1c8a2b32725ca72e0f3256f9cd8cb6">operator[]</a> (size_t n) const </td></tr>
<tr class="memdesc:a2d1c8a2b32725ca72e0f3256f9cd8cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator that returns the value at element <code>n</code> of self.  <a href="#a2d1c8a2b32725ca72e0f3256f9cd8cb6">More...</a><br/></td></tr>
<tr class="separator:a2d1c8a2b32725ca72e0f3256f9cd8cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6a81d36a8905d782b283b9a05893e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#a0f6a81d36a8905d782b283b9a05893e6">operator+=</a> (<a class="el" href="classstk_1_1StkFrames.html">StkFrames</a> &amp;f)</td></tr>
<tr class="memdesc:a0f6a81d36a8905d782b283b9a05893e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment by sum operator into self.  <a href="#a0f6a81d36a8905d782b283b9a05893e6">More...</a><br/></td></tr>
<tr class="separator:a0f6a81d36a8905d782b283b9a05893e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049cbfd10908f754a7c48c1dd0da21e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#a049cbfd10908f754a7c48c1dd0da21e0">operator*=</a> (<a class="el" href="classstk_1_1StkFrames.html">StkFrames</a> &amp;f)</td></tr>
<tr class="memdesc:a049cbfd10908f754a7c48c1dd0da21e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment by product operator into self.  <a href="#a049cbfd10908f754a7c48c1dd0da21e0">More...</a><br/></td></tr>
<tr class="separator:a049cbfd10908f754a7c48c1dd0da21e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813632277bf0c432bcf81136ccdbbec1"><td class="memItemLeft" align="right" valign="top">StkFloat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#a813632277bf0c432bcf81136ccdbbec1">operator()</a> (size_t frame, unsigned int channel)</td></tr>
<tr class="memdesc:a813632277bf0c432bcf81136ccdbbec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel / frame subscript operator that returns a reference.  <a href="#a813632277bf0c432bcf81136ccdbbec1">More...</a><br/></td></tr>
<tr class="separator:a813632277bf0c432bcf81136ccdbbec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e7e4c30affc29d0cdc98e7514188de"><td class="memItemLeft" align="right" valign="top">StkFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#a93e7e4c30affc29d0cdc98e7514188de">operator()</a> (size_t frame, unsigned int channel) const </td></tr>
<tr class="memdesc:a93e7e4c30affc29d0cdc98e7514188de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel / frame subscript operator that returns a value.  <a href="#a93e7e4c30affc29d0cdc98e7514188de">More...</a><br/></td></tr>
<tr class="separator:a93e7e4c30affc29d0cdc98e7514188de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9402d9be28da418f630b4261b9b386"><td class="memItemLeft" align="right" valign="top">StkFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#a4f9402d9be28da418f630b4261b9b386">interpolate</a> (StkFloat frame, unsigned int channel=0) const </td></tr>
<tr class="memdesc:a4f9402d9be28da418f630b4261b9b386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an interpolated value at the fractional frame index and channel.  <a href="#a4f9402d9be28da418f630b4261b9b386">More...</a><br/></td></tr>
<tr class="separator:a4f9402d9be28da418f630b4261b9b386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c41aae98f77487c004085912d1f8f79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c41aae98f77487c004085912d1f8f79"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#a5c41aae98f77487c004085912d1f8f79">size</a> () const </td></tr>
<tr class="memdesc:a5c41aae98f77487c004085912d1f8f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of audio samples represented by the object. <br/></td></tr>
<tr class="separator:a5c41aae98f77487c004085912d1f8f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6652950830fe907f9158ee891560253"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6652950830fe907f9158ee891560253"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#ac6652950830fe907f9158ee891560253">empty</a> () const </td></tr>
<tr class="memdesc:ac6652950830fe907f9158ee891560253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>true</em> if the object size is zero and <em>false</em> otherwise. <br/></td></tr>
<tr class="separator:ac6652950830fe907f9158ee891560253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386e1b86cf48f7a8117313f9e41fc0fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#a386e1b86cf48f7a8117313f9e41fc0fe">resize</a> (size_t nFrames, unsigned int nChannels=1)</td></tr>
<tr class="memdesc:a386e1b86cf48f7a8117313f9e41fc0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize self to represent the specified number of channels and frames.  <a href="#a386e1b86cf48f7a8117313f9e41fc0fe">More...</a><br/></td></tr>
<tr class="separator:a386e1b86cf48f7a8117313f9e41fc0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ecf6563fdd2d3732aa9de2692af32e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#a57ecf6563fdd2d3732aa9de2692af32e">resize</a> (size_t nFrames, unsigned int nChannels, StkFloat value)</td></tr>
<tr class="memdesc:a57ecf6563fdd2d3732aa9de2692af32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize self to represent the specified number of channels and frames and perform element initialization.  <a href="#a57ecf6563fdd2d3732aa9de2692af32e">More...</a><br/></td></tr>
<tr class="separator:a57ecf6563fdd2d3732aa9de2692af32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7ef9c46675a24111aa6e2fda3ba870"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec7ef9c46675a24111aa6e2fda3ba870"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#aec7ef9c46675a24111aa6e2fda3ba870">channels</a> (void) const </td></tr>
<tr class="memdesc:aec7ef9c46675a24111aa6e2fda3ba870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of channels represented by the data. <br/></td></tr>
<tr class="separator:aec7ef9c46675a24111aa6e2fda3ba870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b1ab6fa750a8221a7d65c30e0cdab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05b1ab6fa750a8221a7d65c30e0cdab9"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#a05b1ab6fa750a8221a7d65c30e0cdab9">frames</a> (void) const </td></tr>
<tr class="memdesc:a05b1ab6fa750a8221a7d65c30e0cdab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of sample frames represented by the data. <br/></td></tr>
<tr class="separator:a05b1ab6fa750a8221a7d65c30e0cdab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad528b1c8ea2866570e7d9c2bac0e8b40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#ad528b1c8ea2866570e7d9c2bac0e8b40">setDataRate</a> (StkFloat rate)</td></tr>
<tr class="memdesc:ad528b1c8ea2866570e7d9c2bac0e8b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sample rate associated with the <a class="el" href="classstk_1_1StkFrames.html" title="An STK class to handle vectorized audio data.">StkFrames</a> data.  <a href="#ad528b1c8ea2866570e7d9c2bac0e8b40">More...</a><br/></td></tr>
<tr class="separator:ad528b1c8ea2866570e7d9c2bac0e8b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbbcbdc8db39a803e0861976f7f3522"><td class="memItemLeft" align="right" valign="top">StkFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstk_1_1StkFrames.html#a4dbbcbdc8db39a803e0861976f7f3522">dataRate</a> (void) const </td></tr>
<tr class="memdesc:a4dbbcbdc8db39a803e0861976f7f3522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample rate associated with the <a class="el" href="classstk_1_1StkFrames.html" title="An STK class to handle vectorized audio data.">StkFrames</a> data.  <a href="#a4dbbcbdc8db39a803e0861976f7f3522">More...</a><br/></td></tr>
<tr class="separator:a4dbbcbdc8db39a803e0861976f7f3522"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An STK class to handle vectorized audio data. </p>
<p>This class can hold single- or multi-channel audio data. The data type is always StkFloat and the channel format is always interleaved. In an effort to maintain efficiency, no out-of-bounds checks are performed in this class unless <em>STK_DEBUG</em> is defined.</p>
<p>Internally, the data is stored in a one-dimensional C array. An indexing operator is available to set and retrieve data values. Alternately, one can use pointers to access the data, using the index operator to get an address for a particular location in the data:</p>
<p>StkFloat* ptr = &amp;myStkFrames[0];</p>
<p>Note that this class can also be used as a table with interpolating lookup.</p>
<p>Possible future improvements in this class could include functions to convert to and return other data types.</p>
<p>by Perry R. Cook and Gary P. Scavone, 1995&ndash;2014. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8ed9cc0a4309f786cfe36da9e901fde9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StkFloat &amp; stk::StkFrames::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator that returns a reference to element <code>n</code> of self. </p>
<p>The result can be used as an lvalue. This reference is valid until the resize function is called or the array is destroyed. The index <code>n</code> must be between 0 and size less one. No range checking is performed unless <em>STK_DEBUG</em> is defined. </p>
<div class="fragment"><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;{</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="preprocessor">#if defined(_STK_DEBUG_)</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="preprocessor"></span>  <span class="keywordflow">if</span> ( n &gt;= size_ ) {</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    std::ostringstream error;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    error &lt;&lt; <span class="stringliteral">&quot;StkFrames::operator[]: invalid index (&quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;) value!&quot;</span>;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <a class="code" href="classstk_1_1Stk.html#a48ac73a0d8ca28445ba1a054e1f061ff" title="Static function for error reporting and handling using c-strings.">Stk::handleError</a>( error.str(), StkError::MEMORY_ACCESS );</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;  }</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;  <span class="keywordflow">return</span> data_[n];</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2d1c8a2b32725ca72e0f3256f9cd8cb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StkFloat stk::StkFrames::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator that returns the value at element <code>n</code> of self. </p>
<p>The index <code>n</code> must be between 0 and size less one. No range checking is performed unless <em>STK_DEBUG</em> is defined. </p>
<div class="fragment"><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;{</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="preprocessor">#if defined(_STK_DEBUG_)</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="preprocessor"></span>  <span class="keywordflow">if</span> ( n &gt;= size_ ) {</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    std::ostringstream error;</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    error &lt;&lt; <span class="stringliteral">&quot;StkFrames::operator[]: invalid index (&quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;) value!&quot;</span>;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    <a class="code" href="classstk_1_1Stk.html#a48ac73a0d8ca28445ba1a054e1f061ff" title="Static function for error reporting and handling using c-strings.">Stk::handleError</a>( error.str(), StkError::MEMORY_ACCESS );</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;  }</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  <span class="keywordflow">return</span> data_[n];</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0f6a81d36a8905d782b283b9a05893e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stk::StkFrames::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstk_1_1StkFrames.html">StkFrames</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment by sum operator into self. </p>
<p>The dimensions of the argument are expected to be the same as self. No range checking is performed unless <em>STK_DEBUG</em> is defined. </p>
<div class="fragment"><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;{</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="preprocessor">#if defined(_STK_DEBUG_)</span></div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="preprocessor"></span>  <span class="keywordflow">if</span> ( f.frames() != nFrames_ || f.channels() != nChannels_ ) {</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    std::ostringstream error;</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    error &lt;&lt; <span class="stringliteral">&quot;StkFrames::operator+=: frames argument must be of equal dimensions!&quot;</span>;</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    <a class="code" href="classstk_1_1Stk.html#a48ac73a0d8ca28445ba1a054e1f061ff" title="Static function for error reporting and handling using c-strings.">Stk::handleError</a>( error.str(), StkError::MEMORY_ACCESS );</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;  }</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;  StkFloat *fptr = &amp;f[0];</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  StkFloat *dptr = data_;</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;size_; i++ )</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    *dptr++ += *fptr++;</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a049cbfd10908f754a7c48c1dd0da21e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stk::StkFrames::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstk_1_1StkFrames.html">StkFrames</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment by product operator into self. </p>
<p>The dimensions of the argument are expected to be the same as self. No range checking is performed unless <em>STK_DEBUG</em> is defined. </p>
<div class="fragment"><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;{</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="preprocessor">#if defined(_STK_DEBUG_)</span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="preprocessor"></span>  <span class="keywordflow">if</span> ( f.frames() != nFrames_ || f.channels() != nChannels_ ) {</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    std::ostringstream error;</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    error &lt;&lt; <span class="stringliteral">&quot;StkFrames::operator*=: frames argument must be of equal dimensions!&quot;</span>;</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <a class="code" href="classstk_1_1Stk.html#a48ac73a0d8ca28445ba1a054e1f061ff" title="Static function for error reporting and handling using c-strings.">Stk::handleError</a>( error.str(), StkError::MEMORY_ACCESS );</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;  }</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;  StkFloat *fptr = &amp;f[0];</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;  StkFloat *dptr = data_;</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;size_; i++ )</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    *dptr++ *= *fptr++;</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a813632277bf0c432bcf81136ccdbbec1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StkFloat &amp; stk::StkFrames::operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Channel / frame subscript operator that returns a reference. </p>
<p>The result can be used as an lvalue. This reference is valid until the resize function is called or the array is destroyed. The <code>frame</code> index must be between 0 and <a class="el" href="classstk_1_1StkFrames.html#a05b1ab6fa750a8221a7d65c30e0cdab9" title="Return the number of sample frames represented by the data.">frames()</a> - 1. The <code>channel</code> index must be between 0 and <a class="el" href="classstk_1_1StkFrames.html#aec7ef9c46675a24111aa6e2fda3ba870" title="Return the number of channels represented by the data.">channels()</a> - 1. No range checking is performed unless <em>STK_DEBUG</em> is defined. </p>
<div class="fragment"><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;{</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="preprocessor">#if defined(_STK_DEBUG_)</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="preprocessor"></span>  <span class="keywordflow">if</span> ( frame &gt;= nFrames_ || channel &gt;= nChannels_ ) {</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    std::ostringstream error;</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    error &lt;&lt; <span class="stringliteral">&quot;StkFrames::operator(): invalid frame (&quot;</span> &lt;&lt; frame &lt;&lt; <span class="stringliteral">&quot;) or channel (&quot;</span> &lt;&lt; channel &lt;&lt; <span class="stringliteral">&quot;) value!&quot;</span>;</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    <a class="code" href="classstk_1_1Stk.html#a48ac73a0d8ca28445ba1a054e1f061ff" title="Static function for error reporting and handling using c-strings.">Stk::handleError</a>( error.str(), StkError::MEMORY_ACCESS );</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;  }</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;  <span class="keywordflow">return</span> data_[ frame * nChannels_ + channel ];</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a93e7e4c30affc29d0cdc98e7514188de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StkFloat stk::StkFrames::operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Channel / frame subscript operator that returns a value. </p>
<p>The <code>frame</code> index must be between 0 and <a class="el" href="classstk_1_1StkFrames.html#a05b1ab6fa750a8221a7d65c30e0cdab9" title="Return the number of sample frames represented by the data.">frames()</a> - 1. The <code>channel</code> index must be between 0 and <a class="el" href="classstk_1_1StkFrames.html#aec7ef9c46675a24111aa6e2fda3ba870" title="Return the number of channels represented by the data.">channels()</a> - 1. No range checking is performed unless <em>STK_DEBUG</em> is defined. </p>
<div class="fragment"><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;{</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="preprocessor">#if defined(_STK_DEBUG_)</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="preprocessor"></span>  <span class="keywordflow">if</span> ( frame &gt;= nFrames_ || channel &gt;= nChannels_ ) {</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    std::ostringstream error;</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    error &lt;&lt; <span class="stringliteral">&quot;StkFrames::operator(): invalid frame (&quot;</span> &lt;&lt; frame &lt;&lt; <span class="stringliteral">&quot;) or channel (&quot;</span> &lt;&lt; channel &lt;&lt; <span class="stringliteral">&quot;) value!&quot;</span>;</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    <a class="code" href="classstk_1_1Stk.html#a48ac73a0d8ca28445ba1a054e1f061ff" title="Static function for error reporting and handling using c-strings.">Stk::handleError</a>( error.str(), StkError::MEMORY_ACCESS );</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;  }</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  <span class="keywordflow">return</span> data_[ frame * nChannels_ + channel ];</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4f9402d9be28da418f630b4261b9b386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StkFloat stk::StkFrames::interpolate </td>
          <td>(</td>
          <td class="paramtype">StkFloat&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an interpolated value at the fractional frame index and channel. </p>
<p>This function performs linear interpolation. The <code>frame</code> index must be between 0.0 and <a class="el" href="classstk_1_1StkFrames.html#a05b1ab6fa750a8221a7d65c30e0cdab9" title="Return the number of sample frames represented by the data.">frames()</a> - 1. The <code>channel</code> index must be between 0 and <a class="el" href="classstk_1_1StkFrames.html#aec7ef9c46675a24111aa6e2fda3ba870" title="Return the number of channels represented by the data.">channels()</a> - 1. No range checking is performed unless <em>STK_DEBUG</em> is defined. </p>

</div>
</div>
<a class="anchor" id="a386e1b86cf48f7a8117313f9e41fc0fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stk::StkFrames::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nFrames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nChannels</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize self to represent the specified number of channels and frames. </p>
<p>Changes the size of self based on the number of frames and channels. No element assignment is performed. No memory deallocation occurs if the new size is smaller than the previous size. Further, no new memory is allocated when the new size is smaller or equal to a previously allocated size. </p>

</div>
</div>
<a class="anchor" id="a57ecf6563fdd2d3732aa9de2692af32e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stk::StkFrames::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nFrames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StkFloat&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize self to represent the specified number of channels and frames and perform element initialization. </p>
<p>Changes the size of self based on the number of frames and channels, and assigns <code>value</code> to every element. No memory deallocation occurs if the new size is smaller than the previous size. Further, no new memory is allocated when the new size is smaller or equal to a previously allocated size. </p>

</div>
</div>
<a class="anchor" id="ad528b1c8ea2866570e7d9c2bac0e8b40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stk::StkFrames::setDataRate </td>
          <td>(</td>
          <td class="paramtype">StkFloat&#160;</td>
          <td class="paramname"><em>rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the sample rate associated with the <a class="el" href="classstk_1_1StkFrames.html" title="An STK class to handle vectorized audio data.">StkFrames</a> data. </p>
<p>By default, this value is set equal to the current STK sample rate at the time of instantiation. </p>
<div class="fragment"><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;{ dataRate_ = rate; };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4dbbcbdc8db39a803e0861976f7f3522"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StkFloat stk::StkFrames::dataRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sample rate associated with the <a class="el" href="classstk_1_1StkFrames.html" title="An STK class to handle vectorized audio data.">StkFrames</a> data. </p>
<p>By default, this value is set equal to the current STK sample rate at the time of instantiation. </p>
<div class="fragment"><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;{ <span class="keywordflow">return</span> dataRate_; };</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Stk_8h_source.html">Stk.h</a></li>
</ul>
</div><!-- contents -->
<HR>
<table>
  <tr><td><A HREF="http://ccrma.stanford.edu/software/stk/"><I>The Synthesis ToolKit in C++ (STK)</I></A></td></tr>
  <tr><td>&copy;1995--2014 Perry R. Cook and Gary P. Scavone. All Rights Reserved.</td></tr>
</table>
</BODY>
</HTML>
